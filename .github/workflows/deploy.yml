name: Deploy to Azure Container Instances

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - prod

env:
  AZURE_RESOURCE_GROUP: rg-unity-catalog-search
  ACR_NAME: acrunitycatalog
  WEB_IMAGE_NAME: unity-catalog-web
  BATCH_IMAGE_NAME: unity-catalog-batch

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest
    outputs:
      acr-login-server: ${{ steps.terraform-output.outputs.acr-login-server }}
      environment: ${{ steps.set-env.outputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set environment suffix
      id: set-env
      run: |
        echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false

    - name: Deploy Azure Infrastructure
      id: terraform-deploy
      run: |
        cd azure
        terraform init -reconfigure \
          -backend-config="resource_group_name=${{ secrets.TF_RESOURCE_GROUP_NAME }}" \
          -backend-config="storage_account_name=${{ secrets.TF_STORAGE_ACCOUNT_NAME }}" \
          -backend-config="container_name=tfstate" \
          -backend-config="key=terraform.tfstate"
        terraform workspace select ${{ steps.set-env.outputs.environment }} || terraform workspace new ${{ steps.set-env.outputs.environment }}
        terraform plan -var-file="environments/${{ steps.set-env.outputs.environment }}.tfvars" -out=tfplan
        terraform apply -auto-approve tfplan
      env:
        # Service Principal authentication for Terraform
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        # Application variables
        TF_VAR_mysql_admin_password: ${{ secrets.MYSQL_ADMIN_PASSWORD }}
        TF_VAR_databricks_token: ${{ secrets.DATABRICKS_TOKEN }}
        TF_VAR_databricks_workspace_url: ${{ secrets.DATABRICKS_WORKSPACE_URL }}

    - name: Get Terraform Outputs
      id: terraform-output
      run: |
        cd azure
        
        # Debug: Print environment variables (unobfuscated)
        echo "=== DEBUG: Authentication Variables ==="
        echo "ARM_CLIENT_ID: $ARM_CLIENT_ID"
        echo "ARM_TENANT_ID: $ARM_TENANT_ID"
        echo "ARM_SUBSCRIPTION_ID: $ARM_SUBSCRIPTION_ID"
        echo "ARM_CLIENT_SECRET length: ${#ARM_CLIENT_SECRET}"
        echo "======================================="
        
        # Debug: Show current Azure context
        echo "=== DEBUG: Azure Context ==="
        az account show --output table || echo "Failed to show account"
        echo "============================="
        
        # Debug: Show Terraform backend config
        echo "=== DEBUG: Terraform Backend ==="
        echo "Current directory: $(pwd)"
        ls -la
        echo "Backend file contents:"
        cat backend.tf
        echo "==============================="
        
        # Try to get outputs
        echo "=== DEBUG: Getting Terraform Outputs ==="
        terraform output || echo "Terraform output failed"
        ACR_LOGIN_SERVER=$(terraform output -raw container_registry_login_server)
        echo "ACR_LOGIN_SERVER: $ACR_LOGIN_SERVER"
        echo "acr-login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
        echo "========================================"
        
        # Wait for ACR to be fully ready
        echo "Waiting for ACR to be ready..."
        for i in {1..10}; do
          if az acr check-health --name "${{ env.ACR_NAME }}${{ steps.set-env.outputs.environment }}" --yes; then
            echo "ACR is ready!"
            break
          fi
          echo "ACR not ready yet, waiting 30 seconds..."
          sleep 30
        done
      env:
        # Service Principal authentication for Terraform
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}  

  build-and-push:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Log in to Azure Container Registry
      run: |
        ACR_NAME="${{ env.ACR_NAME }}${{ needs.deploy-infrastructure.outputs.environment }}"
        az acr login --name $ACR_NAME

    - name: Extract metadata for Web image
      id: meta-web
      uses: docker/metadata-action@v5
      with:
        images: ${{ needs.deploy-infrastructure.outputs.acr-login-server }}/${{ env.WEB_IMAGE_NAME }}
        tags: |
          type=raw,value=${{ needs.deploy-infrastructure.outputs.environment }}
          type=sha,prefix=${{ needs.deploy-infrastructure.outputs.environment }}-
          type=raw,value=latest

    - name: Extract metadata for Batch image
      id: meta-batch
      uses: docker/metadata-action@v5
      with:
        images: ${{ needs.deploy-infrastructure.outputs.acr-login-server }}/${{ env.BATCH_IMAGE_NAME }}
        tags: |
          type=raw,value=${{ needs.deploy-infrastructure.outputs.environment }}
          type=sha,prefix=${{ needs.deploy-infrastructure.outputs.environment }}-
          type=raw,value=latest

    - name: Build and push Web image
      id: build-web
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.web.prod
        push: true
        tags: ${{ steps.meta-web.outputs.tags }}
        labels: ${{ steps.meta-web.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push Batch image
      id: build-batch
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.batch.prod
        push: true
        tags: ${{ steps.meta-batch.outputs.tags }}
        labels: ${{ steps.meta-batch.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  update-containers:
    needs: [deploy-infrastructure, build-and-push]
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false

    - name: Update Container Instances
      run: |
        ENV="${{ needs.deploy-infrastructure.outputs.environment }}"
        RG_NAME="${{ env.AZURE_RESOURCE_GROUP }}-${ENV}"
        ACR_NAME="${{ env.ACR_NAME }}${ENV}"
        
        echo "Deleting existing container groups to force image update..."
        
        # Delete Web Container Group
        az container delete \
          --resource-group "$RG_NAME" \
          --name "aci-unity-web-${ENV}" \
          --yes || echo "Web container group not found or already deleted"
        
        # Delete Batch Container Group  
        az container delete \
          --resource-group "$RG_NAME" \
          --name "aci-unity-batch-${ENV}" \
          --yes || echo "Batch container group not found or already deleted"
        
        # Note: MySQL container is NOT deleted to preserve data and avoid downtime
        
        echo "Waiting for deletions to complete..."
        sleep 30
        
        echo "Re-running Terraform to recreate containers with updated images..."
        cd azure
        
        # Initialize Terraform
        terraform init -reconfigure \
          -backend-config="resource_group_name=${{ secrets.TF_RESOURCE_GROUP_NAME }}" \
          -backend-config="storage_account_name=${{ secrets.TF_STORAGE_ACCOUNT_NAME }}" \
          -backend-config="container_name=tfstate" \
          -backend-config="key=terraform.tfstate"
        
        # Select workspace
        terraform workspace select ${{ needs.deploy-infrastructure.outputs.environment }} || terraform workspace new ${{ needs.deploy-infrastructure.outputs.environment }}
        
        # Update Terraform variables to use actual images
        export TF_VAR_web_image="${ACR_NAME}.azurecr.io/unity-catalog-web:latest"
        export TF_VAR_batch_image="${ACR_NAME}.azurecr.io/unity-catalog-batch:latest"
        
        # Apply all container groups (MySQL will be created on first run, updated on subsequent runs)
        terraform apply -auto-approve \
          -target=azurerm_container_group.mysql \
          -target=azurerm_container_group.web \
          -target=azurerm_container_group.batch \
          -target=azurerm_container_group.solr
        
        echo "Waiting for containers to start and initialize..."
        sleep 90  # Give MySQL extra time to initialize database
      env:
        # Service Principal authentication for Terraform
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        # Application variables
        TF_VAR_mysql_admin_password: ${{ secrets.MYSQL_ADMIN_PASSWORD }}
        TF_VAR_databricks_token: ${{ secrets.DATABRICKS_TOKEN }}
        TF_VAR_databricks_workspace_url: ${{ secrets.DATABRICKS_WORKSPACE_URL }}

    - name: Run Health Checks
      run: |
        ENV="${{ needs.deploy-infrastructure.outputs.environment }}"
        RG_NAME="${{ env.AZURE_RESOURCE_GROUP }}-${ENV}"
        
        # Wait for containers to start (reduced since we already waited 90s above)
        sleep 30
        
        # Check web service health
        WEB_URL=$(az container show \
          --resource-group "$RG_NAME" \
          --name "aci-unity-web-${ENV}" \
          --query "ipAddress.fqdn" \
          --output tsv)
        
        if [[ -n "$WEB_URL" ]]; then
          curl -f "http://${WEB_URL}:3000/api/health" || exit 1
          echo "Health check passed for environment: ${ENV}"
        else
          echo "Could not get container URL"
          exit 1
        fi

