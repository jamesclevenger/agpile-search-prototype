name: Deploy to Azure Container Instances

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - prod

env:
  AZURE_RESOURCE_GROUP: rg-unity-catalog-search
  ACR_NAME: acrunitycatalog
  WEB_IMAGE_NAME: unity-catalog-web
  BATCH_IMAGE_NAME: unity-catalog-batch

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest
    outputs:
      acr-login-server: ${{ steps.terraform-output.outputs.acr-login-server }}
      environment: ${{ steps.set-env.outputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set environment suffix
      id: set-env
      run: |
        echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false

    - name: Deploy Azure Infrastructure
      id: terraform-deploy
      run: |
        cd azure
        terraform init -reconfigure \
          -backend-config="resource_group_name=${{ secrets.TF_RESOURCE_GROUP_NAME }}" \
          -backend-config="storage_account_name=${{ secrets.TF_STORAGE_ACCOUNT_NAME }}" \
          -backend-config="container_name=tfstate" \
          -backend-config="key=terraform.tfstate"
        terraform workspace select ${{ steps.set-env.outputs.environment }} || terraform workspace new ${{ steps.set-env.outputs.environment }}
        terraform plan -out=tfplan
        terraform apply -auto-approve tfplan
      env:
        # Service Principal authentication for Terraform
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        # Application variables
        TF_VAR_resource_group_name: ${{ env.AZURE_RESOURCE_GROUP }}
        TF_VAR_location: "West US 2"
        TF_VAR_environment: ${{ needs.deploy-infrastructure.outputs.environment || steps.set-env.outputs.environment }}
        TF_VAR_mysql_admin_password: ${{ secrets.MYSQL_ADMIN_PASSWORD }}
        TF_VAR_databricks_token: ${{ secrets.DATABRICKS_TOKEN }}
        TF_VAR_databricks_workspace_url: ${{ secrets.DATABRICKS_WORKSPACE_URL }}
        TF_VAR_docker_hub_username: ${{ secrets.DOCKER_HUB_USERNAME }}
        TF_VAR_docker_hub_token: ${{ secrets.DOCKER_HUB_TOKEN }}

    - name: Get Terraform Outputs
      id: terraform-output
      run: |
        cd azure
        
        # Get Terraform outputs
        ACR_LOGIN_SERVER=$(terraform output -raw container_registry_login_server)
        echo "acr-login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
        
        # Wait for ACR to be fully ready
        echo "Waiting for ACR to be ready..."
        for i in {1..10}; do
          if az acr check-health --name "${{ env.ACR_NAME }}${{ steps.set-env.outputs.environment }}" --yes; then
            echo "ACR is ready!"
            break
          fi
          echo "ACR not ready yet, waiting 15 seconds... (attempt $i/10)"
          sleep 15
        done
      env:
        # Service Principal authentication for Terraform
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}  

  build-and-push:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Log in to Azure Container Registry
      run: |
        ACR_NAME="${{ env.ACR_NAME }}${{ needs.deploy-infrastructure.outputs.environment }}"
        az acr login --name $ACR_NAME

    - name: Extract metadata for Web image
      id: meta-web
      uses: docker/metadata-action@v5
      with:
        images: ${{ needs.deploy-infrastructure.outputs.acr-login-server }}/${{ env.WEB_IMAGE_NAME }}
        tags: |
          type=raw,value=${{ github.sha }}
          type=raw,value=latest

    - name: Extract metadata for Batch image
      id: meta-batch
      uses: docker/metadata-action@v5
      with:
        images: ${{ needs.deploy-infrastructure.outputs.acr-login-server }}/${{ env.BATCH_IMAGE_NAME }}
        tags: |
          type=raw,value=${{ github.sha }}
          type=raw,value=latest

    - name: Build and push Web image
      id: build-web
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.web.prod
        push: true
        tags: ${{ steps.meta-web.outputs.tags }}
        labels: ${{ steps.meta-web.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push Batch image
      id: build-batch
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.batch.prod
        push: true
        tags: ${{ steps.meta-batch.outputs.tags }}
        labels: ${{ steps.meta-batch.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Wait for images to be available
      run: |
        ACR_NAME="${{ env.ACR_NAME }}${{ needs.deploy-infrastructure.outputs.environment }}"
        
        echo "Waiting for images to be available in ACR..."
        
        # Wait for web image
        for i in {1..30}; do
          if az acr repository show --name "$ACR_NAME" --repository "${{ env.WEB_IMAGE_NAME }}" --query "name" -o tsv &>/dev/null; then
            echo "Web image is available!"
            break
          fi
          echo "Web image not yet available, waiting 10 seconds... (attempt $i/30)"
          sleep 10
        done
        
        # Wait for batch image  
        for i in {1..30}; do
          if az acr repository show --name "$ACR_NAME" --repository "${{ env.BATCH_IMAGE_NAME }}" --query "name" -o tsv &>/dev/null; then
            echo "Batch image is available!"
            break
          fi
          echo "Batch image not yet available, waiting 10 seconds... (attempt $i/30)"
          sleep 10
        done
        
        echo "All images are available in ACR"

  update-containers:
    needs: [deploy-infrastructure, build-and-push]
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false

    - name: Update Container Instances
      run: |
        ENV="${{ needs.deploy-infrastructure.outputs.environment }}"
        RG_NAME="${{ env.AZURE_RESOURCE_GROUP }}-${ENV}"
        ACR_NAME="${{ env.ACR_NAME }}${ENV}"
        
        echo "Updating containers with new images using Terraform..."
        cd azure
        
        # Initialize Terraform
        terraform init -reconfigure \
          -backend-config="resource_group_name=${{ secrets.TF_RESOURCE_GROUP_NAME }}" \
          -backend-config="storage_account_name=${{ secrets.TF_STORAGE_ACCOUNT_NAME }}" \
          -backend-config="container_name=tfstate" \
          -backend-config="key=terraform.tfstate"
        
        # Select workspace
        terraform workspace select ${{ needs.deploy-infrastructure.outputs.environment }} || terraform workspace new ${{ needs.deploy-infrastructure.outputs.environment }}
        
        # Update Terraform variables to use actual images with unique tags to force replacement
        export TF_VAR_web_image="${ACR_NAME}.azurecr.io/unity-catalog-web:${{ github.sha }}"
        export TF_VAR_batch_image="${ACR_NAME}.azurecr.io/unity-catalog-batch:${{ github.sha }}"
        
        # Refresh state and apply changes - Terraform will handle replacements automatically
        terraform refresh
        terraform apply -auto-approve
        
        echo "Terraform deployment completed, containers are starting..."
      env:
        # Service Principal authentication for Terraform
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        # Application variables
        TF_VAR_resource_group_name: ${{ env.AZURE_RESOURCE_GROUP }}
        TF_VAR_location: "West US 2"
        TF_VAR_environment: ${{ needs.deploy-infrastructure.outputs.environment || steps.set-env.outputs.environment }}
        TF_VAR_mysql_admin_password: ${{ secrets.MYSQL_ADMIN_PASSWORD }}
        TF_VAR_databricks_token: ${{ secrets.DATABRICKS_TOKEN }}
        TF_VAR_databricks_workspace_url: ${{ secrets.DATABRICKS_WORKSPACE_URL }}
        TF_VAR_docker_hub_username: ${{ secrets.DOCKER_HUB_USERNAME }}
        TF_VAR_docker_hub_token: ${{ secrets.DOCKER_HUB_TOKEN }}

    - name: Run Health Checks
      run: |
        ENV="${{ needs.deploy-infrastructure.outputs.environment }}"
        RG_NAME="${{ env.AZURE_RESOURCE_GROUP }}-${ENV}"
        
        echo "Waiting for all services to be ready..."
        
        # Function to check container status
        check_container_status() {
          local container_name=$1
          local service_name=$2
          
          echo "Checking $service_name status..."
          for i in {1..20}; do
            STATUS=$(az container show \
              --resource-group "$RG_NAME" \
              --name "$container_name" \
              --query "containers[0].instanceView.currentState.state" \
              --output tsv 2>/dev/null || echo "NotFound")
            
            if [[ "$STATUS" == "Running" ]]; then
              echo "$service_name is running!"
              return 0
            fi
            echo "$service_name status: $STATUS, waiting 15 seconds... (attempt $i/20)"
            sleep 15
          done
          echo "ERROR: $service_name failed to start"
          return 1
        }
        
        # Check all services
        check_container_status "aci-unity-mysql-${ENV}" "MySQL"
        
        # Detailed Solr diagnostics
        echo "=== DETAILED SOLR DIAGNOSTICS ==="
        SOLR_STATUS=$(az container show \
          --resource-group "$RG_NAME" \
          --name "aci-unity-solr-${ENV}" \
          --query "containers[0].instanceView.currentState.state" \
          --output tsv 2>/dev/null || echo "NotFound")
        
        echo "Solr container status: $SOLR_STATUS"
        
        # Get Solr container full details
        echo "=== Solr Container Configuration ==="
        az container show --resource-group "$RG_NAME" --name "aci-unity-solr-${ENV}" --query "containers[0]" -o json || echo "Failed to get container config"
        
        # Get Solr container logs
        echo "=== Solr Container Logs ==="
        az container logs --resource-group "$RG_NAME" --name "aci-unity-solr-${ENV}" || echo "Failed to get Solr logs"
        
        # Get Solr network details
        echo "=== Solr Network Details ==="
        SOLR_FQDN=$(az container show --resource-group "$RG_NAME" --name "aci-unity-solr-${ENV}" --query "ipAddress.fqdn" -o tsv || echo "None")
        SOLR_IP=$(az container show --resource-group "$RG_NAME" --name "aci-unity-solr-${ENV}" --query "ipAddress.ip" -o tsv || echo "None")
        echo "Solr FQDN: $SOLR_FQDN"
        echo "Solr IP: $SOLR_IP"
        
        # Test Solr connectivity from deployment runner
        if [[ -n "$SOLR_FQDN" && "$SOLR_FQDN" != "None" ]]; then
          echo "=== Testing Solr Connectivity ==="
          
          # Test basic port connectivity
          echo "Testing port 8983 connectivity..."
          if timeout 10 bash -c "</dev/tcp/$SOLR_FQDN/8983" 2>/dev/null; then
            echo "‚úÖ Solr port 8983 is accessible"
          else
            echo "‚ùå Solr port 8983 is not accessible"
          fi
          
          # Test Solr admin endpoint
          echo "Testing Solr admin ping..."
          ADMIN_RESPONSE=$(curl -v -s -w "HTTP_CODE:%{http_code}" "http://$SOLR_FQDN:8983/solr/admin/ping" 2>&1 || echo "CURL_FAILED")
          echo "Admin ping response: $ADMIN_RESPONSE"
          
          # Test Solr cores list
          echo "Testing Solr cores list..."
          CORES_RESPONSE=$(curl -v -s -w "HTTP_CODE:%{http_code}" "http://$SOLR_FQDN:8983/solr/admin/cores" 2>&1 || echo "CURL_FAILED")
          echo "Cores list response: $CORES_RESPONSE"
          
          # Test specific unity_catalog core
          echo "Testing unity_catalog core..."
          CORE_RESPONSE=$(curl -v -s -w "HTTP_CODE:%{http_code}" "http://$SOLR_FQDN:8983/solr/unity_catalog/admin/ping" 2>&1 || echo "CURL_FAILED")
          echo "Unity catalog core response: $CORE_RESPONSE"
          
          # Test Solr status endpoint
          echo "Testing Solr status..."
          STATUS_RESPONSE=$(curl -v -s -w "HTTP_CODE:%{http_code}" "http://$SOLR_FQDN:8983/solr/admin/info/system" 2>&1 || echo "CURL_FAILED")
          echo "System status response: $STATUS_RESPONSE"
        fi
        
        # Continue with regular check but don't fail on Solr yet
        if ! check_container_status "aci-unity-solr-${ENV}" "Solr"; then
          echo "‚ùå Solr failed status check - see diagnostics above"
          echo "Continuing without Solr for now..."
        fi
        
        # Now test web service with longer timeouts
        echo "=== WEB SERVICE TESTING (with extended Solr wait time) ==="
        
        # Get web service URL
        WEB_URL=$(az container show \
          --resource-group "$RG_NAME" \
          --name "aci-unity-web-${ENV}" \
          --query "ipAddress.fqdn" \
          --output tsv)
        
        if [[ -n "$WEB_URL" ]]; then
          echo "Web URL: $WEB_URL"
          
          # Check web container status
          WEB_STATUS=$(az container show --resource-group "$RG_NAME" --name "aci-unity-web-${ENV}" --query "containers[0].instanceView.currentState.state" -o tsv 2>/dev/null || echo "NotFound")
          echo "Web container status: $WEB_STATUS"
          
          if [[ "$WEB_STATUS" == "Running" ]]; then
            echo "‚úÖ Web container is running"
            
            # Test health endpoint with patience for Solr initialization
            echo "Testing web service health endpoint (allowing time for Solr initialization)..."
            for i in {1..20}; do  # Increased from 15 to 20 attempts
              echo "Health check attempt $i/20..."
              
              if curl -f -s "http://${WEB_URL}:3000/api/health" > /dev/null; then
                echo "‚úÖ Web service health check passed!"
                echo "üåê Application URL: http://${WEB_URL}:3000"
                
                # Show the health response for confirmation
                HEALTH_RESPONSE=$(curl -s "http://${WEB_URL}:3000/api/health" | head -c 200)
                echo "Health response preview: $HEALTH_RESPONSE"
                
                # Test search functionality
                echo "Testing search API..."
                SEARCH_TEST=$(curl -s "http://${WEB_URL}:3000/api/search/test" | head -c 300)
                echo "Search test result: $SEARCH_TEST"
                
                break
              else
                echo "‚è≥ Health check failed, waiting 60 seconds... (attempt $i/20)"
                if [[ "$i" -lt 20 ]]; then
                  sleep 60  # Increased from 45 to 60 seconds
                fi
              fi
            done
            
            # Final check
            if curl -f -s "http://${WEB_URL}:3000/api/health" > /dev/null; then
              echo "üéâ Deployment successful for environment: ${ENV}"
              echo "üåê Application is ready at: http://${WEB_URL}:3000"
            else
              echo "‚ö†Ô∏è  Web service still not healthy, but Solr diagnostics show it should work eventually"
              echo "üåê Try accessing the application directly: http://${WEB_URL}:3000"
              echo "Note: It may take a few more minutes for all services to be fully ready"
            fi
          else
            echo "‚ùå Web container not running: $WEB_STATUS"
            az container logs --resource-group "$RG_NAME" --name "aci-unity-web-${ENV}" || echo "Could not get web logs"
          fi
        else
          echo "‚ùå Could not get web container URL"
        fi

