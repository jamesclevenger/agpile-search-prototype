name: Deploy to Azure Container Instances

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  AZURE_RESOURCE_GROUP: rg-unity-catalog-search
  ACR_NAME: acrunitycatalog
  WEB_IMAGE_NAME: unity-catalog-web
  BATCH_IMAGE_NAME: unity-catalog-batch

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest
    outputs:
      acr-login-server: ${{ steps.terraform-output.outputs.acr-login-server }}
      environment: ${{ steps.set-env.outputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set environment suffix
      id: set-env
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "environment=prod" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
          echo "environment=dev" >> $GITHUB_OUTPUT
        else
          echo "environment=dev" >> $GITHUB_OUTPUT
        fi

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false

    - name: Deploy Azure Infrastructure
      id: terraform-deploy
      run: |
        cd azure
        terraform init -reconfigure
        terraform workspace select ${{ steps.set-env.outputs.environment }} || terraform workspace new ${{ steps.set-env.outputs.environment }}
        terraform plan -var-file="environments/${{ steps.set-env.outputs.environment }}.tfvars" -out=tfplan
        terraform apply -auto-approve tfplan
      env:
        TF_VAR_mysql_admin_password: ${{ secrets.MYSQL_ADMIN_PASSWORD }}
        TF_VAR_databricks_token: ${{ secrets.DATABRICKS_TOKEN }}
        TF_VAR_databricks_workspace_url: ${{ secrets.DATABRICKS_WORKSPACE_URL }}

    - name: Get Terraform Outputs
      id: terraform-output
      run: |
        cd azure
        ACR_LOGIN_SERVER=$(terraform output -raw container_registry_login_server)
        echo "acr-login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
        
        # Wait for ACR to be fully ready
        echo "Waiting for ACR to be ready..."
        for i in {1..10}; do
          if az acr check-health --name "${{ env.ACR_NAME }}${{ steps.set-env.outputs.environment }}" --yes; then
            echo "ACR is ready!"
            break
          fi
          echo "ACR not ready yet, waiting 30 seconds..."
          sleep 30
        done

  build-and-push:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Log in to Azure Container Registry
      run: |
        ACR_NAME="${{ env.ACR_NAME }}${{ needs.deploy-infrastructure.outputs.environment }}"
        az acr login --name $ACR_NAME

    - name: Extract metadata for Web image
      id: meta-web
      uses: docker/metadata-action@v5
      with:
        images: ${{ needs.deploy-infrastructure.outputs.acr-login-server }}/${{ env.WEB_IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Extract metadata for Batch image
      id: meta-batch
      uses: docker/metadata-action@v5
      with:
        images: ${{ needs.deploy-infrastructure.outputs.acr-login-server }}/${{ env.BATCH_IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Web image
      id: build-web
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.web.prod
        push: true
        tags: ${{ steps.meta-web.outputs.tags }}
        labels: ${{ steps.meta-web.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push Batch image
      id: build-batch
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.batch.prod
        push: true
        tags: ${{ steps.meta-batch.outputs.tags }}
        labels: ${{ steps.meta-batch.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  update-containers:
    needs: [deploy-infrastructure, build-and-push]
    runs-on: ubuntu-latest
    
    steps:
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Update Container Instances
      run: |
        ENV="${{ needs.deploy-infrastructure.outputs.environment }}"
        RG_NAME="${{ env.AZURE_RESOURCE_GROUP }}-${ENV}"
        ACR_NAME="${{ env.ACR_NAME }}${ENV}"
        
        # Update Web Container with new image
        az container exec \
          --resource-group "$RG_NAME" \
          --name "aci-unity-web-${ENV}" \
          --container-name web \
          --exec-command "echo 'Stopping placeholder container'" || true
        
        # Force update by deleting and recreating container group
        echo "Updating container images..."
        az deployment group create \
          --resource-group "$RG_NAME" \
          --template-file azure/container-update.json \
          --parameters \
            webImage="${ACR_NAME}.azurecr.io/unity-catalog-web:latest" \
            batchImage="${ACR_NAME}.azurecr.io/unity-catalog-batch:latest" \
            environment="$ENV" \
          --mode Incremental \
          --wait

    - name: Run Health Checks
      run: |
        ENV="${{ needs.deploy-infrastructure.outputs.environment }}"
        RG_NAME="${{ env.AZURE_RESOURCE_GROUP }}-${ENV}"
        
        # Wait for containers to start
        sleep 60
        
        # Check web service health
        WEB_URL=$(az container show \
          --resource-group "$RG_NAME" \
          --name "aci-unity-web-${ENV}" \
          --query "ipAddress.fqdn" \
          --output tsv)
        
        if [[ -n "$WEB_URL" ]]; then
          curl -f "http://${WEB_URL}:3000/api/health" || exit 1
          echo "Health check passed for environment: ${ENV}"
        else
          echo "Could not get container URL"
          exit 1
        fi

  cleanup:
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    runs-on: ubuntu-latest
    
    steps:
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Cleanup PR Resources
      run: |
        # Clean up any PR-specific resources if they exist
        PR_NUMBER=${{ github.event.number }}
        echo "Cleaning up resources for PR #${PR_NUMBER}"